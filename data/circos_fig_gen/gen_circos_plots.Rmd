---
title: "poster"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(circlize)
library(readxl)

args = commandArgs(trailingOnly=TRUE)
setwd("~/SequencingData/poster/data/circos_fig_gen")

mags.df <- read.table("../mag_summary_stats.tab", sep = "\t", header=TRUE) #contains summary statistics
cytoband.df <- read.table("../cytoband.txt", sep = "\t", header = TRUE) #contains plotting data

#processes each contig's data one at a time, produce a circos plot before moving to the next
for (i in 1:nrow(mags.df)) {
  
  sample <- mags.df[i,1] 
  classification <- mags.df[i,3]
  #retrieve cytoband information
  edge_num <- mags.df$Edge_num[i]
  if (edge_num %in% cytoband.df$Edge_num) {
    index <- which(cytoband.df$Edge_num == edge_num)
    cytoband_info <- cytoband.df[index, 1:5] #extract the one row with relevant cytoband information to the current contig
  }
  contig <- cytoband_info[1,1]
  length <- cytoband_info[1,3]
  
  if (file.exists(sprintf("../../www/%s+%s.pdf", sample, edge_num))) {
    next  # Skip to the next iteration
  }
  
  ###------------------------------------------------------
  
  #bed files for polished coverage
  polish_path <- sprintf("./polished_depth/%s.regions.bed", mags.df$Filename[i])
  #FIXME no unpolished data for now, but this is here as a placeholder. With unpolished data, point to the bed files containing the unpolished alignments
  unpolish_path <- sprintf("./polished_depth/%s.regions.bed", mags.df$Filename[i])

  contig.pol <- read.table(polish_path, header = FALSE, sep="\t", stringsAsFactors = FALSE, quote="")
  contig.unpol <- read.table(unpolish_path, header = FALSE, sep="\t", stringsAsFactors = FALSE, quote="")
  
  #FIXME Imported bed data can end up having different number of rows between unpolished and polished, and the code will error out from trying to join the frames later. This will crop the longer dataframe so that it works - not ideal but works for now
  row_select <- min(nrow(contig.pol), nrow(contig.unpol))
  contig.pol <- contig.pol[0:row_select,]
  contig.unpol <- contig.unpol[0:row_select,]

  #Create master bed containing both unfiltered and filtered coverage. Use this for plotting
  bed.concat <- contig.pol
  colnames(bed.concat) <- c("chr", "start", "end")
  bed.concat$contig.pol <- contig.pol$V4
  bed.concat$contig.unpol <- contig.unpol$V4
  
  #Sets the max coverage displayed, which should be twice the mean (so the mean will be positioned in the middle of the plot).
  covmax <- mean(contig.pol$V4)*2
  bed.concat$contig.pol[which(bed.concat$contig.pol > covmax)] <- covmax
  bed.concat$contig.unpol[which(bed.concat$contig.unpol > covmax)] <- covmax

  
  ###------------------------------------------------------

  #GC info
  gc_path <- sprintf("./gc_info/%s.fasta-gc-information.txt", mags.df$Filename[i])
  
  gc_info <- read.table(paste0(gc_path), header=TRUE,
                        nrows = row_select)
  
  gc_mean<- round((mean(gc_info[,1])), digits = 2)
  
  #generate bed for gc content (gc script extracts gcinfo for 100 base window) 
  mean_prop = mean(mean(gc_info[,1]))
  zero = 0
  
  mean_prop <- data.frame(rep(mean_prop, row_select))
  zero <- data.frame(rep(0, row_select))
  
  chr <- data.frame(rep(contig, ((length/1000)+1)))
    chr <- head(chr, row_select)
  
  starts <- seq(from = 0, to = (length), by = 1000)
    starts <- head(starts, row_select)
  
  ends <- seq(from = 1000, to = (length+1000), by = 1000)
    ends <- head(ends, row_select)
    
  gc_content <- gc_info[,1]
    gc_content <- head(gc_content, row_select)
  
  gc_skew <- gc_info[,2]
    gc_skew <- gc_skew / max(gc_skew) # the gc_skew and gc_culm columns need to converted to a proportion (i.e. between 0.0 to 1.0) to be plotted on the same track.
    gc_skew <- head(gc_skew, row_select)
    
  gc_culm <- gc_info[,3]
    gc_culm <- gc_culm / max(abs(gc_culm))
    gc_culm <- head(gc_culm, row_select)
    
  #FIXME number of rows may differ again, by maybe 1 or 2 windows.
    
  gc_bed <- data.frame(chr, starts, ends, gc_content, gc_skew, gc_culm, mean_prop, zero)
  colnames(gc_bed) <- c('chr','start','end','gc_content','gc_skew','gc_culm', 'mean_prop', 'zero')
  
  ###------------------------------------------------------
  
  cds_path <- sprintf("./CDS/%s.tab", mags.df$Filename[i])
  #path to file containing CDS regions (IN XLSX FORMAT!) So after the code to get the CDS... itll be the {contig}.gff.txt.txt file (naming is weird but ill fix later). Convert that to xlsx and direct it here.
  
  cds <- read.table(cds_path, col.names = c("V1", "V2", "V3", "V4", "V5", "V6", "V7", "V8", "V9"), sep="\t")
  
  cds.for <- subset(cds, V7 == "+" & V3 == "CDS", select = c(V1,V4,V5,V8))
    cds.for$V8 = 1
    colnames(cds.for) <- c("chr", "start", "end", "cov")
    
  cds.rev <- subset(cds, V7 == "-" & V3 == "CDS", select = c(V1,V4,V5,V8))
    cds.rev$V8 = 1
    colnames(cds.rev) <- c("chr", "start", "end", "cov")
  
  tRNA <- subset(cds, V3 == "tRNA", select = c(V1,V4,V5,V8))
    tRNA$V8 = 1
    colnames(tRNA) <- c("chr", "start", "end", "cov")
    tRNA <-data.frame(tRNA)
    
  rRNA <- subset(cds, V3 == "rRNA", select = c(V1,V4,V5,V8))
    try(rRNA$V8 <- 1, silent = TRUE)
    colnames(rRNA) <- c("chr", "start", "end", "cov")
    rRNA <-data.frame(rRNA)
    
  #Seems like it'll get the wrong name into the chr column, so the tracks don't render. Replace with the correct naming
    cds.for$chr <- contig
    cds.rev$chr <- contig
    tRNA$chr <- contig
    try (rRNA$chr <- contig, silent = TRUE)

#--------------------------------- GENERATE CIRCOS PLOT
    
png(sprintf("../../www/%s+%s.png", sample, edge_num), width = 2000, height = 2000, res = 200)

circos.clear()

circos.par(start.degree=75, gap.after = 30, cell.padding=c(0,0,0,0))
circos.initializeWithIdeogram(cytoband_info, plotType = NA)

#COVERAGE
circos.genomicTrack(bed.concat, numeric.column=c("contig.pol", "contig.unpol"), ylim = c(0,covmax), panel.fun = function(region, value, ...) {
  circos.genomicAxis(h = "top", labels.cex = 1.1, tickLabelsStartFromZero = TRUE, major.by = 200000)
  circos.genomicLines(region, value, numeric.column="contig.unpol", baseline = 0, col = "#D8D8D8", border = NA, area=TRUE, ...)
  circos.genomicLines(region, value, numeric.column="contig.pol", baseline = 0, col = "#2971FF", border = NA, area=TRUE, ...)
  },
  track.height = 0.15,
  bg.border = NA
    )

circos.text(0, covmax, labels = as.integer(covmax), adj=c(1.6, 0), cex = 0.7, col = "#000000")
circos.text(0, 0, labels = "0", cex = 0.7, adj=c(1.6, 0), col = "#000000")

#GCINFO
#GC content on its own track
circos.genomicTrackPlotRegion(gc_bed, numeric.column="gc_content" , ylim = c(min(gc_bed$gc_content),max(gc_bed$gc_content)), panel.fun = function(region, value, ...) {
    circos.genomicLines(region, value, numeric.column="gc_content", baseline = 0, col = "#0353A4", border = NA, ...)
    circos.genomicLines(region, value, numeric.column="mean_prop", baseline = 0, col = "#B9D6F2", border = NA, ...)
    }, bg.border = NA, track.height = 0.1)

circos.text(0, gc_mean, labels = paste(gc_mean), cex = 0.6, adj=c(1, 0.5), col = "#000000", track.index = 2)

# plot GC skew and culmulative skew.
circos.genomicTrackPlotRegion(gc_bed, numeric.column=c("gc_culm", "gc_skew"), ylim = c(-1, 1), panel.fun = function(region, value, ...) {
  circos.genomicLines(region, value, numeric.column="gc_culm", baseline = 0, col = "#CCD1D1", border = NA, area=TRUE,...)
  circos.genomicLines(region, value, numeric.column="gc_skew", baseline = 0, col = "#005b96", border = NA,...)
      circos.genomicLines(region, value, numeric.column="zero", baseline = 0, col = "#B9D6F2", border = NA, ...)
}, bg.border = NA, track.height = 0.1)

#CDS FORWARD
circos.genomicTrack(cds.for, ylim = c(0,1), panel.fun = function(region, value, ...) {
    print(region,value)
    # in every region, print a vertical line at the start region.
  for (k in seq_len(nrow(region))){
    # plot vertical lines for each START of the ORF from bottom to top.
      circos.lines(rep(region[k, 1], 2), c(0, 1), lwd = 0.2, straight = TRUE, col = "#7ab0ed66")}
  },
  track.height = 0.05,
  bg.border = NA
    )

#CDS BACKWARD
circos.genomicTrack(cds.rev, ylim = c(0,1), panel.fun = function(region, value, ...) {
  # in every region, print a vertical line at the start region.
  for (k in seq_len(nrow(region))){
    # plot vertical lines for each START of the ORF from bottom to top.
      circos.lines(rep(region[k, 1], 2), c(0, 1), lwd = 0.2, straight = TRUE, col = "#BBD1EA66")}
  },
  track.height = 0.05,
  bg.border = NA
    )

#tRNA AND rRNA
circos.genomicTrack(list(tRNA, rRNA), ylim = c(0,1), panel.fun = function(region, value, ...) {
 # this will iterate through the list of bed dataframes (trna and rrna)
  i = getI(...)
  # plot tRNAs as light
  if (i == 1){
    for (k in seq_len(nrow(region))){
      # plot vertical lines for each START of the orf from bottom to top.
        circos.lines(rep(region[k, 1], 2), c(0, 1), lwd = 2, straight = TRUE, col = "#DAE3E5")
    }
  } 
  
  else {
    # plot rRNAs as dark
    for (k in seq_len(nrow(region))){
      # plot vertical lines for each START of the orf from bottom to top.
        circos.lines(rep(region[k, 1], 2), c(0, 1), lwd = 2, straight = TRUE, col = "#0353A4")
      }
    }
  },
  track.height = 0.05,
  bg.border = NA
    )

text(0,0, paste0(classification), cex=3)

#FIXME sometimes, sample names are too long and overlap the tracks
text(0,-0.05, paste0("Sample: ", sample), cex=1.7, pos=1)
text(0, -0.15, sprintf("Classification: %s", mags.df$Class2[i]), cex = 1, col = "#000000")
text(0, -0.2, paste0("Size: ", length), cex = 1, col = "#000000")


text(0, 0.88, "Coverage", cex = 1.5, col = "#000000")
#text(-0.07, 0.85, "Unfiltered", cex = 1, col = "#aeaeae")
#text(0.07, 0.85, "Filtered", cex = 1, col = "#2971FF")
text(0, 0.76, "GC content", cex = 1.3, col = "#000000")
text(0, 0.625, "GC skew", cex = 1.3, col = "#000000")
text(0, 0.54, "CDS (+)", cex = 1.3, col = "#000000")
text(0, 0.47, "CDS (-)", cex = 1.3, col = "#000000")
text(0, 0.42, "tRNA (light)", cex = 1, col = "#000000")
text(0, 0.39, "rRNA (dark)", cex = 1, col = "#000000")

dev.off()

}

```
